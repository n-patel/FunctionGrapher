FunctionGrapher: Design Information
This document contains details on the implementation and design of the project.

FunctionGrapher is a Java project utilizing the Swing GUI toolkit.  The program allows users to graph functions and change how they are visualized.  Additionally, the application queries Wolfram Alpha and displays relevant information.  Users can save and load functions/configurations for convenience purposes.

One noticeable trait of the source is the use of the singleton design pattern for some classes.  Although some claim that the use of singletons is an anti-pattern and 'evil' because it allows the class to control its own instantiation, I used singletons because I frequently found myself needing to access the instance of various panels on the application frame.  This program lends itself to the singleton design pattern, as I only needed one instance of any panel at any given moment.  Each panel on the application also implements the AbstractPanel interface that I created.  This interface essentially makes initializing the panels more consistent and much easier.  Before using this interface, I had many lines of similar code when I initialized the panels.  After creating the interface, I was able to remove that code and condense it into a single line per panel.

In terms of listening for events, I used the ActionListener interface, which is probably the most common way to handle Swing events.  However, in order to maintain cleaner code, I moved the listeners to separate classes (rather than leaving them as anonymous inner classes).  Unfortunately, this posed a problem -- I was now unable to get the instance of the component that sent the event in order to influence the application properly.  Thus, I chose to use action commands, which fire the given command upon the firing of an event.  The action listener classes are now able to act appropriately when receiving an action, and more commands can easily be added if needed.

The Expr library (https://github.com/darius/expr) is used for parsing expressions.  The string which the user inputs for the function is validated by Expr, and then I repeatedly ask Expr to evaluate the result (y) for the given x coordinates.  Each of these x-y pairs are then graphed and connected to form a smooth line.  One challenge which I faced was how to deal with discontinuities.  When graphing a function with discontinuities (for example, tan(x)), Function would actually connect the end of the previous segment and beginning of the next in order to remove the discontinuity.  This is an error that is difficult to fix.  I alleviated part of the problem by checking that the segment doesn't extend below and above the window (as this seemed to be a trait of the segments connecting discontinuities -- they tended to have very small and large values (negative infinity to positive infinity)).  Unfortunately, the error still isn't fixed entirely today.  The graph of tan(x) looks normal at the default axes intervals, but if the axes are extended to extremely large values the aforementioned error persists.  Additionally, the program doesn't handle undefined values appropriately; sqrt(x) will draw a horizontal line from negative infinity to 0 and then a vertical line at 0.  Both errors, discontinuities and undefined values, persist today and I know of no way to fix either.

Saving and loading configurations was easier than I expected.  Utilizing the Java Properties API, the program allows users to save the current state to a .properties file to be loaded in at another point in time (this code can be found in the FileIO class).  Saving and loading properties access getters/setters of the function and axes config panels instances (thanks to the help of the singleton design pattern).  This means that if more panels/fields are added in the future, they have to manually be added to the saving/loading methods.  A default configuration is provided in the compiled jar to be loaded on startup; there is also a reset button in the application which will load in the default properties.

The Wolfram Alpha querying was probably the most difficult piece of the program even though Wolfram Alpha generously provides a library (which unfortunately requires the use of 4 others) and a detailed code example for querying.  In fact, obtaining the query result from Wolfram Alpha was a breeze.  The difficult part was making it run in a separate thread and obtaining the result when the thread completed.  My first solution was simple, but locked up the entire application while querying.  This was frustrating, so I attempted to devise various ways to make the querying process run on another thread.  However, I ran into the same problem each time: I had no way of knowing when the query finished and therefore would attempt to obtain the result before the query had ran.  The solution I almost settled for solved this problem but created a high degree of coupling between classes: I set the text field from the query method, directly accessing the text area on the Wolfram Alpha panel on the application.  I was still unsatisfied with this solution.  After some research, I eventually found a clean way (the use of an interface, TaskListener, to act as an intermediary of sorts) to notify the panel when the query thread finished working.  I am quite pleased with this solution, although I'm not fond of the Wolfram Alpha-related code as a whole, as it is a bit too messy for my liking.